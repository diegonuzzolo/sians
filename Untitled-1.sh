#!/bin/bash
set -e

# Argomenti
TYPE=$1
SLUG=$2
URL=$3
METHOD=$4
SERVER_ID=$5
GAME_VERSION=$6
SERVER_VERSION=$6






KEYWORDS=("Exception" "Caused by" "mod incompatibility" "MissingMods" "FabricLoader")



# Percorsi
BASE_DIR="/home/diego/minecraft_servers/$SERVER_ID"
LOG_FILE="/home/diego/setup_log_${SERVER_ID}.log"
MODPACK_ZIP="$BASE_DIR/modpack.zip"
MODRINTH_URL="https://api.modrinth.com/v2/project/$SLUG/version?game_versions=[\"$GAME_VERSION\"]&loaders=[\"fabric\"]"
PID_FILE="/home/diego/setup_pid_${SERVER_ID}.pid"
SERVER_DIR="$BASE_DIR"
UPDATE_URL="https://sians.it/update_status.php"
UPDATE_TOKEN="la_luna_il_mio_cane_numero_uno"
LOG_FILE="$SERVER_DIR/logs/latest.log"
ERROR_LOG="$SERVER_DIR/debug/error_analysis.log"
MODS_DIR="$SERVER_DIR/mods"

mkdir -p "$MODS_DIR"
mkdir -p "$SERVER_DIR/logs"
mkdir -p "$SERVER_DIR/debug"

check_for_errors() {
    for keyword in "${KEYWORDS[@]}"; do
        if grep -q "$keyword" "$LOG_FILE"; then
            echo "[$(date)] âŒ Trovato errore con keyword '$keyword'" >> "$ERROR_LOG"
            echo "Ultime righe:" >> "$ERROR_LOG"
            tail -n 50 "$LOG_FILE" >> "$ERROR_LOG"
            echo -e "\n---\n" >> "$ERROR_LOG"

            # Qui puoi inserire logica per azioni automatiche
            # es: disabilitare una mod problematica (rinomina .jar -> .disabled)
        fi
    done
}

while true; do
    if [ -f "$LOG_FILE" ]; then
        check_for_errors
    fi
    sleep 10
done

mkdir -p "$SERVER_DIR"
touch "$LOG_FILE"
chmod 644 "$LOG_FILE"
echo "[$(date)] Avvio installazione server $SERVER_ID (tipo: $TYPE)" >> "$LOG_FILE"







update_status() {
    local status="$1"
    local progress="$2"
    echo "[$(date)] Chiamata update_status con status=$status, progress=$progress" >> "$LOG_FILE"
    curl -s -X POST -H "Content-Type: application/json" \
         -H "Authorization: Bearer $UPDATE_TOKEN" \
         -d "{\"server_id\": \"$SERVER_ID\", \"status\": \"$status\", \"progress\": $progress}" \
         "$UPDATE_URL" > /dev/null
}

# Funzione log
log() {
    echo "[$(date)] $1" | tee -a "$LOG_FILE"
}

update_status "installing" 5

cd "$SERVER_DIR"

cat > server.properties <<EOF
#Minecraft server properties
#Generated by setup script
spawn-protection=16
max-tick-time=60000
query.port=25565
generator-settings=
force-gamemode=false
allow-nether=true
enforce-whitelist=false
gamemode=0
broadcast-console-to-ops=true
enable-query=false
player-idle-timeout=0
difficulty=2
spawn-monsters=true
op-permission-level=4
pvp=true
snooper-enabled=true
level-type=default
hardcore=false
enable-command-block=false
max-players=50
network-compression-threshold=256
resource-pack-sha1=
max-world-size=29999984
function-permission-level=2
rcon.port=25575
server-port=25565
server-ip=0.0.0.0
spawn-npcs=true
allow-flight=false
level-name=world
view-distance=32
resource-pack=
motd=Il tuo server
generate-structures=true
max-build-height=256
online-mode=true
level-seed=
use-native-transport=true
enable-rcon=false
EOF

install_fabric_modrinth() {
    GAME_VERSIONS_ENCODED='%5B%22'"$GAME_VERSION"'%22%5D'
    LOADERS_ENCODED='%5B%22fabric%22%5D'
    MODRINTH_URL="https://api.modrinth.com/v2/project/$SLUG/version?game_versions=$GAME_VERSIONS_ENCODED&loaders=$LOADERS_ENCODED"

    log "ðŸ“¦ Recupero metadati modpack da Modrinth: $MODRINTH_URL"
    VERSIONS_JSON=$(curl -s "$MODRINTH_URL")
    
    log "DEBUG: Risposta API Modrinth (prima 500 caratteri):"
    echo "$VERSIONS_JSON" | head -c 500 >> "$LOG_FILE"
    
    DOWNLOAD_URL=$(echo "$VERSIONS_JSON" | jq -r --arg ver "$GAME_VERSION" \
        '.[] | select(.game_versions[] == $ver and .version_type == "release") | .files[0].url' | head -n 1)
    
    log "DEBUG: DOWNLOAD_URL trovato: $DOWNLOAD_URL"
    if [ -z "$DOWNLOAD_URL" ] || [ "$DOWNLOAD_URL" == "null" ]; then
        log "âŒ Errore: Nessuna versione compatibile trovata per $GAME_VERSION"
        update_status "failed" 0
        exit 1
    fi

    log "â¬‡ï¸ Scarico modpack da $DOWNLOAD_URL"
    curl -L -o "$MODPACK_ZIP" "$DOWNLOAD_URL"
    
    if [ ! -s "$MODPACK_ZIP" ]; then
        log "âŒ Errore: File $MODPACK_ZIP vuoto o non scaricato correttamente."
        update_status "failed" 0
        exit 1
    fi

    log "ðŸ“ Estraggo modpack..."
    unzip -o "$MODPACK_ZIP" -d "$BASE_DIR"
    rm "$MODPACK_ZIP"
    chown -R diego:diego "$SERVER_DIR"
    chmod -R u+rwX "$SERVER_DIR"
    log "DEBUG: Contenuto cartella $BASE_DIR dopo unzip:"
    ls -l "$BASE_DIR" >> "$LOG_FILE"
    
    INDEX_JSON="$BASE_DIR/modrinth.index.json"
    if [ ! -f "$INDEX_JSON" ]; then
        log "âŒ Errore: File modrinth.index.json non trovato!"
        update_status "failed" 0
        exit 1
    fi

    MODS_DIR="mods"
mkdir -p "$MODS_DIR"

MOD_COUNT=$(jq '.files | length' "$INDEX_JSON")

for i in $(seq 0 $((MOD_COUNT - 1))); do
    MOD_PATH=$(jq -r ".files[$i].path" "$INDEX_JSON")
    MOD_NAME=$(basename "$MOD_PATH")

    MOD_URL=$(jq -r ".files[$i].downloads[0] // empty" "$INDEX_JSON")

    if [ -z "$MOD_URL" ]; then
        log "âš ï¸  Ignoro mod senza URL valido: $MOD_NAME (indice $i)"
        continue
    fi

    TMP_FILE="${MODS_DIR}/${MOD_NAME}.tmp"
    if curl --retry 5 --retry-delay 3 -L -o "$TMP_FILE" "$MOD_URL"; then
        if unzip -tq "$TMP_FILE" >/dev/null 2>&1; then
            mv "$TMP_FILE" "$MODS_DIR/$MOD_NAME"
            log "âœ”ï¸  Scaricata e verificata: $MOD_NAME"
        else
            log "âŒ Mod corrotta (ZIP non valido): $MOD_NAME â€” eliminata"
            rm -f "$TMP_FILE"
        fi
    else
        log "âŒ Errore download mod: $MOD_NAME"
        rm -f "$TMP_FILE"
    fi
done




    FABRIC_JAR_URL="https://meta.fabricmc.net/v2/versions/loader/$GAME_VERSION/0.16.14/1.0.3/server/jar"
    FABRIC_JAR="$BASE_DIR/server.jar"

    log "â¬‡ï¸ Scarico Fabric server jar..."
    curl -L -o "$FABRIC_JAR" "$FABRIC_JAR_URL"

    log "âœ… Installazione modpack completata."
}

# -------------------- INSTALLAZIONE ----------------------

if [ "$TYPE" == "vanilla" ]; then
    update_status "installing" 10
    VANILLA_MANIFEST_URL="https://launchermeta.mojang.com/mc/game/version_manifest.json"
    VANILLA_URL=$(curl -s "$VANILLA_MANIFEST_URL" | jq -r --arg VERSION "$SERVER_VERSION" \
        '.versions[] | select(.id == $VERSION) | .url' | xargs curl -s | jq -r '.downloads.server.url')

    if [ -z "$VANILLA_URL" ] || [ "$VANILLA_URL" == "null" ]; then
        log "âŒ Impossibile trovare la versione vanilla $SERVER_VERSION"
        update_status "failed" 0
        exit 1
    fi

    log "â¬‡ï¸ Scarico server vanilla $SERVER_VERSION..."
    curl -L -o server.jar "$VANILLA_URL"
    update_status "installing" 40

elif [ "$TYPE" == "paper" ]; then
    update_status "installing" 10
    # Ottieni ultima build disponibile per la versione richiesta
    BUILD=$(curl -s "https://api.papermc.io/v2/projects/paper/versions/$SERVER_VERSION" | jq -r '.builds[-1]')
    if [ -z "$BUILD" ] || [ "$BUILD" == "null" ]; then
        log "âŒ Nessuna build Paper trovata per la versione $SERVER_VERSION"
        update_status "failed" 0
        exit 1
    fi

    PAPER_URL="https://api.papermc.io/v2/projects/paper/versions/$SERVER_VERSION/builds/$BUILD/downloads/paper-$SERVER_VERSION-$BUILD.jar"
    log "â¬‡ï¸ Scarico Paper $SERVER_VERSION (build $BUILD)..."
    curl -L -o server.jar "$PAPER_URL"
    update_status "installing" 40

elif [ "$TYPE" == "modpack" ]; then
    update_status "installing" 10

    if [ "$METHOD" == "modrinth" ]; then
        update_status "installing" 30
        install_fabric_modrinth
        update_status "installing" 90
    else
        log "âŒ Metodo non supportato per modpack: $METHOD"
        update_status "failed" 0
        exit 1
    fi
fi

# Accetta EULA
echo "eula=true" > eula.txt

# Accetta EULA
echo "eula=true" > "$SERVER_DIR/eula.txt"

# start.sh
cat > "$SERVER_DIR/start.sh" <<EOF
#!/bin/bash
cd "\$(dirname "\$0")"
screen -dmS mc_$SERVER_ID java -Xmx10G -Xms10G -jar server.jar nogui
EOF

# stop.sh
cat > "$SERVER_DIR/stop.sh" <<EOF
#!/bin/bash
screen -S mc_$SERVER_ID -X stuff "stop$(printf '\r')"
EOF

# monitor.sh
cat > "$SERVER_DIR/monitor.sh" <<'EOF'
#!/bin/bash

SERVER_DIR="$(dirname "$0")"
LOG_FILE="$SERVER_DIR/logs/latest.log"
MONITOR_LOG="$SERVER_DIR/monitor_log.txt"
MODS_DIR="$SERVER_DIR/mods"
DISABLED_DIR="$SERVER_DIR/mods_disabled"
RESTART_LIMIT=3
RESTART_COUNT_FILE="$SERVER_DIR/.restart_count"

mkdir -p "$DISABLED_DIR"

if [[ -f "$RESTART_COUNT_FILE" ]]; then
    RESTART_COUNT=$(cat "$RESTART_COUNT_FILE")
else
    RESTART_COUNT=0
fi

echo "[$(date)] â–¶ Monitoraggio server avviato." >> "$MONITOR_LOG"

tail -n0 -F "$LOG_FILE" | while read -r line; do
    echo "$line" | grep -Ei "Exception|ERROR|Caused by|crash|incompatible mod|mod .* failed|Mod ID:" >/dev/null
    if [[ $? -eq 0 ]]; then
        echo "[$(date)] âŒ Problema rilevato: $line" >> "$MONITOR_LOG"

        MOD_NAME=""
        MOD_NAME=$(echo "$line" | grep -Po "Mod ID: '\K[a-zA-Z0-9_\-]+(?=')")
        [[ -z "$MOD_NAME" ]] && MOD_NAME=$(echo "$line" | grep -Po "mod '\K[a-zA-Z0-9_\-]+(?=')")
        [[ -z "$MOD_NAME" ]] && MOD_NAME=$(echo "$line" | grep -Po "[a-zA-Z0-9_\-]+(?= failed)" | head -n1)

        if [[ -n "$MOD_NAME" ]]; then
            MOD_FILE=$(find "$MODS_DIR" -iname "*$MOD_NAME*.jar" | head -n 1)
            if [[ -f "$MOD_FILE" ]]; then
                echo "[$(date)] âš ï¸ Mod sospetta: $MOD_NAME -> $(basename "$MOD_FILE")" >> "$MONITOR_LOG"
                mv "$MOD_FILE" "$DISABLED_DIR/"
                echo "[$(date)] ðŸ”• Mod disattivata: $(basename "$MOD_FILE")" >> "$MONITOR_LOG"
            else
                echo "[$(date)] âš ï¸ Mod $MOD_NAME non trovata." >> "$MONITOR_LOG"
            fi
        else
            echo "[$(date)] âš ï¸ Nome mod non identificabile." >> "$MONITOR_LOG"
        fi

        if [[ $RESTART_COUNT -lt $RESTART_LIMIT ]]; then
            echo "[$(date)] ðŸ”„ Riavvio tentativo $((RESTART_COUNT + 1))" >> "$MONITOR_LOG"
            screen -S mc_$SERVER_ID -X quit
            sleep 3
            screen -dmS mc_$SERVER_ID bash "$SERVER_DIR/start.sh"
            RESTART_COUNT=$((RESTART_COUNT + 1))
            echo "$RESTART_COUNT" > "$RESTART_COUNT_FILE"
            echo "[$(date)] âœ… Server riavviato." >> "$MONITOR_LOG"
        else
            echo "[$(date)] ðŸš« Limite riavvii superato." >> "$MONITOR_LOG"
            break
        fi
    fi
done
EOF

chmod +x "$SERVER_DIR/start.sh" "$SERVER_DIR/stop.sh" "$SERVER_DIR/monitor.sh"

# Avvia server e monitor
screen -dmS mc_$SERVER_ID bash "$SERVER_DIR/start.sh"
screen -dmS monitor_$SERVER_ID bash "$SERVER_DIR/monitor.sh"

# ðŸ”„ Mantieni la progress bar attiva finchÃ© monitor.sh Ã¨ in esecuzione
while screen -list | grep -q "monitor_$SERVER_ID"; do
    curl -s -X POST -H "Authorization: Bearer $UPDATE_TOKEN" \
        -d "{\"server_id\": \"$SERVER_ID\", \"status\": \"monitoring\"}" "$UPDATE_URL" > /dev/null
    sleep 5
done

# Quando termina il monitoraggio, passa a stato "running"
curl -s -X POST -H "Authorization: Bearer $UPDATE_TOKEN" \
    -d "{\"server_id\": \"$SERVER_ID\", \"status\": \"running\"}" "$UPDATE_URL" > /dev/null
