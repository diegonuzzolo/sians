#!/bin/bash
set -e

# Argomenti
TYPE=$1
SLUG=$2
URL=$3
METHOD=$4
SERVER_ID=$5
GAME_VERSION=$6
SERVER_VERSION=$6






KEYWORDS=("Exception" "Caused by" "mod incompatibility" "MissingMods" "FabricLoader")



# Percorsi
BASE_DIR="/home/diego/minecraft_servers/$SERVER_ID"
LOG_FILE="/home/diego/setup_log_${SERVER_ID}.log"
MODPACK_ZIP="$BASE_DIR/modpack.zip"
MODRINTH_URL="https://api.modrinth.com/v2/project/$SLUG/version?game_versions=[\"$GAME_VERSION\"]&loaders=[\"fabric\"]"
PID_FILE="/home/diego/setup_pid_${SERVER_ID}.pid"
SERVER_DIR="$BASE_DIR"
UPDATE_URL="https://sians.it/update_status.php"
UPDATE_TOKEN="la_luna_il_mio_cane_numero_uno"
LOG_FILE="$SERVER_DIR/logs/latest.log"
ERROR_LOG="$SERVER_DIR/debug/error_analysis.log"
MODS_DIR="$SERVER_DIR/mods"

mkdir -p "$MODS_DIR"
mkdir -p "$SERVER_DIR/logs"
mkdir -p "$SERVER_DIR/debug"

# Funzione log
log() {
    echo "[$(date)] $1" | tee -a "$LOG_FILE"
}
mkdir -p "$SERVER_DIR"
touch "$LOG_FILE"
chmod 644 "$LOG_FILE"
log "[$(date)] Avvio installazione server $SERVER_ID (tipo: $TYPE)" >> "$LOG_FILE"







update_status() {
    local status="$1"
    local progress="$2"
    echo "[$(date)] Chiamata update_status con status=$status, progress=$progress" >> "$LOG_FILE"
    curl -s -X POST -H "Content-Type: application/json" \
         -H "Authorization: Bearer $UPDATE_TOKEN" \
         -d "{\"server_id\": \"$SERVER_ID\", \"status\": \"$status\", \"progress\": $progress}" \
         "$UPDATE_URL" > /dev/null
}



update_status "installing" 5

cd "$SERVER_DIR"

cat > server.properties <<EOF
#Minecraft server properties
#Generated by setup script
spawn-protection=16
max-tick-time=60000
query.port=25565
generator-settings=
force-gamemode=false
allow-nether=true
enforce-whitelist=false
gamemode=0
broadcast-console-to-ops=true
enable-query=false
player-idle-timeout=0
difficulty=2
spawn-monsters=true
op-permission-level=4
pvp=true
snooper-enabled=true
level-type=default
hardcore=false
enable-command-block=false
max-players=50
network-compression-threshold=256
resource-pack-sha1=
max-world-size=29999984
function-permission-level=2
rcon.port=25575
server-port=25565
server-ip=0.0.0.0
spawn-npcs=true
allow-flight=false
level-name=world
view-distance=32
resource-pack=
motd=Il tuo server
generate-structures=true
max-build-height=256
online-mode=true
level-seed=
use-native-transport=true
enable-rcon=false
EOF

install_fabric_modrinth() {
    GAME_VERSIONS_ENCODED='%5B%22'"$GAME_VERSION"'%22%5D'
    LOADERS_ENCODED='%5B%22fabric%22%5D'
    MODRINTH_URL="https://api.modrinth.com/v2/project/$SLUG/version?game_versions=$GAME_VERSIONS_ENCODED&loaders=$LOADERS_ENCODED"

    log "üì¶ Recupero metadati modpack da Modrinth: $MODRINTH_URL"
    VERSIONS_JSON=$(curl -s "$MODRINTH_URL")
    
    log "DEBUG: Risposta API Modrinth (prima 500 caratteri):"
    echo "$VERSIONS_JSON" | head -c 500 >> "$LOG_FILE"
    
    DOWNLOAD_URL=$(echo "$VERSIONS_JSON" | jq -r --arg ver "$GAME_VERSION" \
        '.[] | select(.game_versions[] == $ver and .version_type == "release") | .files[0].url' | head -n 1)
    
    log "DEBUG: DOWNLOAD_URL trovato: $DOWNLOAD_URL"
    if [ -z "$DOWNLOAD_URL" ] || [ "$DOWNLOAD_URL" == "null" ]; then
        log "‚ùå Errore: Nessuna versione compatibile trovata per $GAME_VERSION"
        update_status "failed" 0
        exit 1
    fi

    log "‚¨áÔ∏è Scarico modpack da $DOWNLOAD_URL"
    curl -L -o "$MODPACK_ZIP" "$DOWNLOAD_URL"
    
    if [ ! -s "$MODPACK_ZIP" ]; then
        log "‚ùå Errore: File $MODPACK_ZIP vuoto o non scaricato correttamente."
        update_status "failed" 0
        exit 1
    fi

    log "üìÅ Estraggo modpack..."
    unzip -o "$MODPACK_ZIP" -d "$BASE_DIR"
    rm "$MODPACK_ZIP"
    chown -R diego:diego "$SERVER_DIR"
    chmod -R u+rwX "$SERVER_DIR"
    log "DEBUG: Contenuto cartella $BASE_DIR dopo unzip:"
    ls -l "$BASE_DIR" >> "$LOG_FILE"
    
    INDEX_JSON="$BASE_DIR/modrinth.index.json"
    if [ ! -f "$INDEX_JSON" ]; then
        log "‚ùå Errore: File modrinth.index.json non trovato!"
        update_status "failed" 0
        exit 1
    fi

    MODS_DIR="mods"
mkdir -p "$MODS_DIR"

MOD_COUNT=$(jq '.files | length' "$INDEX_JSON")

for i in $(seq 0 $((MOD_COUNT - 1))); do
    MOD_PATH=$(jq -r ".files[$i].path" "$INDEX_JSON")
    MOD_NAME=$(basename "$MOD_PATH")

    MOD_URL=$(jq -r ".files[$i].downloads[0] // empty" "$INDEX_JSON")

    if [ -z "$MOD_URL" ]; then
        log "‚ö†Ô∏è  Ignoro mod senza URL valido: $MOD_NAME (indice $i)"
        continue
    fi
    TMP_FILE="${MODS_DIR}/${MOD_NAME}.tmp"
    if curl --retry 5 --retry-delay 5 --connect-timeout 10 --max-time 3600 --fail -L -o "$TMP_FILE" "$MOD_URL"; then
        if unzip -tq "$TMP_FILE" >/dev/null 2>&1; then
            mv "$TMP_FILE" "$MODS_DIR/$MOD_NAME"
            log "‚úîÔ∏è  Scaricata e verificata: $MOD_NAME"
        else
            log "‚ùå Mod corrotta (ZIP non valido): $MOD_NAME ‚Äî eliminata"
            rm -f "$TMP_FILE"
        fi
    else
        log "‚ùå Errore download mod: $MOD_NAME"
        rm -f "$TMP_FILE"
    fi
done
log "‚úÖ Installazione modpack completata."

# Percorso dove si trova modrinth.index.json
MODRINTH_DIR="/home/diego/minecraft_servers/$SERVER_ID"  # <-- Modifica questo
if [ ! -f "$MODRINTH_DIR/modrinth.index.json" ]; then
    log "‚ùå File modrinth.index.json non trovato in $MODRINTH_DIR"
    exit 1
fi

# Leggi versioni da modrinth.index.json
fabric_loader_version=$(jq -r '.dependencies["fabric-loader"]' "$MODRINTH_DIR/modrinth.index.json")
minecraft_version=$(jq -r '.dependencies.minecraft' "$MODRINTH_DIR/modrinth.index.json")

log "‚û°Ô∏è Minecraft version: $minecraft_version"
log "‚û°Ô∏è Fabric loader version: $fabric_loader_version"

# Recupera la lista delle versioni del loader
json=$(curl --connect-timeout 60 --max-time 300 -s "https://meta.fabricmc.net/v2/versions/loader/${minecraft_version}/${fabric_loader_version}/server")

# Recupera installer_version se disponibile
installer_version=$(echo "$json" | jq -r '.[0].version // empty')

# Se installer_version √® vuoto, fallback a un valore predefinito (opzionale)
if [ -z "$installer_version" ]; then
    log "‚ö†Ô∏è Nessun installer trovato per Fabric $fabric_loader_version + MC $minecraft_version"
    exit 1
fi

log "üì• Downloading Fabric server: loader=$fabric_loader_version, installer=$installer_version, mc=$minecraft_version"

# Scarica il server jar con nome corretto
wget --timeout=300 --tries=10 -O fabric-server-launch.jar \
    "https://meta.fabricmc.net/v2/versions/loader/${minecraft_version}/${fabric_loader_version}/${installer_version}/server/jar"

if [ $? -ne 0 ]; then
    log "‚ùå Errore durante il download del fabric-server-launch.jar"
    exit 1
fi


    log "‚úÖ Server Fabric scaricato correttamente."
}

# -------------------- INSTALLAZIONE ----------------------

if [ "$TYPE" == "vanilla" ]; then
    update_status "installing" 10
    VANILLA_MANIFEST_URL="https://launchermeta.mojang.com/mc/game/version_manifest.json"
    VANILLA_URL=$(curl -s "$VANILLA_MANIFEST_URL" | jq -r --arg VERSION "$SERVER_VERSION" \
        '.versions[] | select(.id == $VERSION) | .url' | xargs curl -s | jq -r '.downloads.server.url')

    if [ -z "$VANILLA_URL" ] || [ "$VANILLA_URL" == "null" ]; then
        log "‚ùå Impossibile trovare la versione vanilla $SERVER_VERSION"
        update_status "failed" 0
        exit 1
    fi

    log "‚¨áÔ∏è Scarico server vanilla $SERVER_VERSION..."
    curl -L -o server.jar "$VANILLA_URL"
    update_status "installing" 40

elif [ "$TYPE" == "paper" ]; then
    update_status "installing" 10
    # Ottieni ultima build disponibile per la versione richiesta
    BUILD=$(curl -s "https://api.papermc.io/v2/projects/paper/versions/$SERVER_VERSION" | jq -r '.builds[-1]')
    if [ -z "$BUILD" ] || [ "$BUILD" == "null" ]; then
        log "‚ùå Nessuna build Paper trovata per la versione $SERVER_VERSION"
        update_status "failed" 0
        exit 1
    fi

    PAPER_URL="https://api.papermc.io/v2/projects/paper/versions/$SERVER_VERSION/builds/$BUILD/downloads/paper-$SERVER_VERSION-$BUILD.jar"
    log "‚¨áÔ∏è Scarico Paper $SERVER_VERSION (build $BUILD)..."
    curl -L -o server.jar "$PAPER_URL"
    update_status "installing" 40

elif [ "$TYPE" == "modpack" ]; then
    update_status "installing" 10

    if [ "$METHOD" == "modrinth" ]; then
        update_status "installing" 30
        install_fabric_modrinth
        update_status "installing" 90
    else
        log "‚ùå Metodo non supportato per modpack: $METHOD"
        update_status "failed" 0
        exit 1
    fi
fi

# Accetta EULA
log "eula=true" > eula.txt

# Accetta EULA
log "eula=true" > "$SERVER_DIR/eula.txt"

# start.sh
cat > "$SERVER_DIR/start.sh" <<EOF
#!/bin/bash
cd "\$(dirname "\$0")"
screen -dmS mc_$SERVER_ID java -Xmx10G -Xms10G -jar server.jar nogui
EOF

# stop.sh
cat > "$SERVER_DIR/stop.sh" <<EOF
#!/bin/bash
screen -S mc_$SERVER_ID -X stuff "stop$(printf '\r')"
EOF

# monitor.sh
cat > "$SERVER_DIR/monitor.sh" <<'EOF'
#!/bin/bash

SERVER_DIR="$(dirname "$0")"
LOG_FILE="$SERVER_DIR/logs/latest.log"
MONITOR_LOG="$SERVER_DIR/monitor_log.txt"
MODS_DIR="$SERVER_DIR/mods"
DISABLED_DIR="$SERVER_DIR/mods_disabled"
RESTART_LIMIT=100
RESTART_COUNT_FILE="$SERVER_DIR/.restart_count"
SERVER_ID=$(basename "$SERVER_DIR")

mkdir -p "$DISABLED_DIR"

# Inizializza contatore riavvii
if [[ -f "$RESTART_COUNT_FILE" ]]; then
    RESTART_COUNT=$(cat "$RESTART_COUNT_FILE")
else
    RESTART_COUNT=0
fi

echo "[$(date)] ‚ñ∂ Monitoraggio server avviato (prime 600 righe)." >> "$MONITOR_LOG"

# Leggi solo le prime 600 righe del log
head -n 600 "$LOG_FILE" | while read -r line; do
    echo "$line" | grep -Ei "Exception|ERROR|Caused by|crash|incompatible mod|mod .* failed|Mod ID:|\.jar" >/dev/null
    if [[ $? -eq 0 ]]; then
        echo "[$(date)] ‚ùå Problema rilevato: $line" >> "$MONITOR_LOG"

        # Estrai nome mod sospetto da pi√π pattern
        MOD_NAME=""
        MOD_NAME=$(echo "$line" | grep -Po "Mod ID: '\K[^']+")
        [[ -z "$MOD_NAME" ]] && MOD_NAME=$(echo "$line" | grep -Po "mod '\K[^']+")
        [[ -z "$MOD_NAME" ]] && MOD_NAME=$(echo "$line" | grep -Po "[^ ]+(?= failed)")
        [[ -z "$MOD_NAME" ]] && MOD_NAME=$(echo "$line" | grep -Po "[^/ ]+\.jar" | sed 's/.jar$//' | head -n1)

        if [[ -n "$MOD_NAME" ]]; then
            MOD_FILE=$(find "$MODS_DIR" -iname "*$MOD_NAME*.jar" | head -n 1)
            if [[ -f "$MOD_FILE" ]]; then
                echo "[$(date)] ‚ö†Ô∏è Mod sospetta: $MOD_NAME -> $(basename "$MOD_FILE")" >> "$MONITOR_LOG"
                mv "$MOD_FILE" "$DISABLED_DIR/"
                echo "[$(date)] üîï Mod disattivata: $(basename "$MOD_FILE")" >> "$MONITOR_LOG"
            else
                echo "[$(date)] ‚ö†Ô∏è Mod file '$MOD_NAME' non trovato in $MODS_DIR" >> "$MONITOR_LOG"
            fi
        else
            echo "[$(date)] ‚ö†Ô∏è Nome mod non identificabile dal log: $line" >> "$MONITOR_LOG"
        fi

        # Riavvia il server se possibile
        if [[ $RESTART_COUNT -lt $RESTART_LIMIT ]]; then
            echo "[$(date)] üîÑ Riavvio tentativo $((RESTART_COUNT + 1))" >> "$MONITOR_LOG"
            screen -S mc_$SERVER_ID -X quit
            sleep 3
            screen -dmS mc_$SERVER_ID bash "$SERVER_DIR/start.sh"
            RESTART_COUNT=$((RESTART_COUNT + 1))
            echo "$RESTART_COUNT" > "$RESTART_COUNT_FILE"
            echo "[$(date)] ‚úÖ Server riavviato." >> "$MONITOR_LOG"
        else
            echo "[$(date)] üö´ Limite riavvii superato." >> "$MONITOR_LOG"
            break
        fi
    fi
done


EOF

chmod +x "$SERVER_DIR/start.sh" "$SERVER_DIR/stop.sh" "$SERVER_DIR/monitor.sh"

# Avvia server e monitor
screen -dmS mc_$SERVER_ID bash "$SERVER_DIR/start.sh"
screen -dmS monitor_$SERVER_ID bash "$SERVER_DIR/monitor.sh"

# üîÑ Mantieni la progress bar attiva finch√© monitor.sh √® in esecuzione
while screen -list | grep -q "monitor_$SERVER_ID"; do
    curl -s -X POST -H "Authorization: Bearer $UPDATE_TOKEN" \
        -d "{\"server_id\": \"$SERVER_ID\", \"status\": \"monitoring\"}" "$UPDATE_URL" > /dev/null
    sleep 5
done

# Quando termina il monitoraggio, passa a stato "running"
curl -s -X POST -H "Authorization: Bearer $UPDATE_TOKEN" \
    -d "{\"server_id\": \"$SERVER_ID\", \"status\": \"running\"}" "$UPDATE_URL" > /dev/null






